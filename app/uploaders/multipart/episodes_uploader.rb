class EpisodesUploader < ::MoviesUploader

  extend S3Multipart::Uploader::Core

  # Attaches the specified model to the uploader, creating a "has_one" 
  # relationship between the internal upload model and the given model.
  attach :episodes

  # Only accept certain file types. Expects an array of valid extensions.
  accept %w(webm wmv avi mp4 mkv mov mpeg)

  # Define the minimum and maximum allowed file sizes (in bytes)
  # limit min: 5*1000*1000, max: 2*1000*1000*1000
  limit min: 10, max: 4*1000*1000*1000

  # Takes in a block that will be evaluated when the upload has been 
  # successfully initiated. The block will be passed an instance of 
  # the upload object as well as the session hashwhen the callback is made. 
  # 
  # The following attributes are available on the upload object:
  # - key:       A randomly generated unique key to replace the file
  #              name provided by the client
  # - upload_id: A hash generated by Amazon to identify the multipart upload
  # - name:      The name of the file (including extensions)
  # - location:  The location of the file on S3. Available only to the
  #              upload object passed into the on_complete callback
  #
  # on_begin do |upload, session|
  #   # Code to be evaluated when upload begins.
  # end

  on_begin do |upload, session|
    # Code to be evaluated when upload begins.
    puts "on_begin movie up, upload ---> #{upload.to_json}"
    puts "on_begin movie up, session ---> #{session.to_json}"
  end

  # See above comment. Called when the upload has successfully completed
  # on_complete do |upload, session|
  #   # Code to be evaluated when upload completes
  # end

  on_complete do |upload, session|
    # Code to be evaluated when upload completes   
    puts "on_complete , upload ---> #{upload.to_json}"
    puts "on_complete , session ---> #{session.to_json}"  
    # film_video = "https://d1jqh0kfebho7s.cloudfront.net/"+upload.key

    puts "-------------------"

    upload_location = upload.location
    file_type = MIME::Types.type_for(upload_location).first.content_type.split("/").last rescue nil

    puts "saving video as Episode"

    @serial =  Serial.find_by(id: session[:current_serial_id]) || Serial.new

    Rails.logger.debug session[:current_serial_id]
    Rails.logger.debug @serial

    episode  = Serial.episodes&.order('updated_at desc')&.first 
    episode.update(
      s3_multipart_upload_id: upload.id,
      uploader: upload.uploader,
      film_video: upload_location,
      video_size: upload.size,
      video_format: file_type
    )  #name: upload.name,


    episode.season_id = session[:episode_season_id]
    episode.build_movie_thumbnail
    episode.save(validate: false)
  end
end
